# contest 851 (2025-6-23)

## [problem C](https://codeforces.com/contest/1788/problem/C)

我们假设最小的「点对和」为 $s_1$，题目要求「点对和」构成一个公差为 1 且项数为 $N$ 的序列，
这个「点对和」构成的等差数列的总和应等于所有点的总和，即 $1 \dots 2N$ 的总和。
因此我们可以得到以下等式
$$ \frac{(s_1 + s_1 + N - 1)N}{2} = \frac{(1 + 2N)2N}{2} $$
可以计算出，$s_1 = (3 + 3N) / 2$，如果给定 $N$ 找不到 $s_1$ 的整数解，说明答案不存在，即如果 $N$ 是偶数则答案不存在。
当 $N$ 为奇数时，我们总是可以构造答案为：
$$(1, s_1 - 1), (2, s_3 - 2), \dots (N / 2, s_{N} - N / 2), (N / 2 + 1, s_2 - {N / 2 + 1}), \dots (N, s_{N-1})$$
前部分构造奇数 $s$, 后半部分构造偶数 $s$。

## [problem D](https://codeforces.com/contest/1788/problem/D)

先考虑包含所有点的情况，因为点总是朝离其最近的点的方向移动。观察相邻的两个点的移动，可能相向、相背、或者同相。

一些相向移动的相邻的点总是最早相遇停止，停在了某些位置上, 其余的点总是向这些位置靠拢，最终被其中一个位置捕获。
当所有的点都停止移动后，最终保留的点（位置）就是最初由相向移动且相邻的点相遇的位置。

因此，我们可以认为最终保留的位置数量是由每一个相邻相向的「点对」贡献的。

因为枚举子集再对每个子集进行计算在时间复杂度上是不可实现的（ $N = 3000$ )，所以我们考虑从「点对」的角度累计贡献，具体做法：

遍历一对「点对」 $i$， $j$，其中 $i < j$， 由其二者相遇位置提供贡献 1 的子集可以描述为：

* 满足相邻：$i$ 和 $j$ 中间不能选取其他的点；
* 满足相向：且设 $i$ 与 $j$ 的距离为 $d$，
$i$ 的左边不能存在距离小于等于 $d$ 的点，$j$ 的右边不能存在距离小于 $d$ 的点（可以取等）。

在以上子集里 $i$，$j$ 满足相邻且相向的，所以它们相遇的点将为每个满足条件的子集提供贡献 1。
以上条件的子集可以通过组合问题计算，这个子集存在 $i$ 和 $j$ 两个确定点，
对 $i$ 左边距离大于 $d$ 的点 （假设有 $x$ 个），和 $j$ 右边距离大于等于 $d$ 的点 （假设有 $y$ 个）可以选取任意数量，
所以满足条件的子集数量为 $2^{x + y}$。因为点坐标具有单调性，所以这里的 $x$ 和 $y$ 可以通过二分找到。

最终的时间复杂度为 $O(\log N \times N^2)$。
