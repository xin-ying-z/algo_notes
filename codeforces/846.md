# contest 876 (2025-6-22)

## [problem D](https://codeforces.com/contest/1780/problem/D)

此题为交互题，交互题常常容易想出一个粗糙的思路，但因为设计的算法的询问次数没想清楚或者调试困难而最终未能通过。

注意题目给出的$n \leq 10^9$ ( 30 个 bit )，同时每个样例询问次数的限制为 30 次，提示我们可以从 bit 位的纬度进行思考。

考虑当我们对一个数「减 1」操作后会发生的情况：

* 如果这个数的结尾是 1，例如「1011」，减 1 之后会变成「1010」，1 的个数减少了 1。

* 如果这个数的结尾是 0，减 1 操作后，「1000」 会变成 「0111」，「1100」会变成「1011」，即原本最低位的 1 会变成 0，而末尾连续的 0 会变成 1。

根据以上性质，我们可以考虑以下算法：

假设当前数的 1 的个数为```cnt```，我们在```cnt != 0```的情况下循环执行减1操作，即询问中的```x = 1```。

这时得到一个新的回复，为操作后的1的个数，设为```ncnt```，```ncnt``` 和 ```cnt```的关系有以下 2 种情况：

* ```cnt - ncnt = 1``` : 这对应着「原数中最末尾为 1 的情况」那我们只需要对答案累加上 1；

* ```ncnt >= cnt``` : 这对应着 「原数中末尾是一段连续0的情况」，从以上例子可得到，当我们知道了```cnt```和```ncnt```之间的差值，我们就知道原数中的最低位1在第```ncnt - cnt + 1```位上。
因此我们可以对答案累加上 $2^{ncnt - cnt + 1}$，即 ```1 << (ncnt - cnt + 1)```。

但是因为第二种情况会对原数的后缀造成「破坏」，在找到最低位的 1 的同时引入了多余的连续1后缀，表示为 $2^{ncnt - cnt + 1} - 1$，所以我们应该去除其影响。
为了不增加额外的询问次数，可以将它增加到下一次的询问的```x```上一起减去。
即令```t = (1 << (ncnt - cnt + 1)) + 1```, ```x = 1 + t```。

因为每次询问我们都会处理最低位的 1 所以最多不超过 30 次询问可以找到答案，满足题目要求。
